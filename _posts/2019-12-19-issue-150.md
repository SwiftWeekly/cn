---
layout: post
title: ! 'Issue #150'
author: btb
---

ä¸€ã€‚ äº”ã€‚ é›¶ã€‚æˆ‘ä»¬è¿æ¥äº†ç¬¬ 150 ä¸ª issues! äº†ä¸èµ·çš„æˆå°±ï¼Œå€¼å¾—ä¸€æçš„æ˜¯ï¼Œè¿™ä¹Ÿæ˜¯ä»Šå¹´æœ€åä¸€ç¯‡é€šè®¯ã€‚

é¦–å…ˆæ„Ÿè°¢ Jesse Squires å¯åŠ¨äº†è¿™ä¸ªé¡¹ç›®å¹¶ä¸€ç›´ç»´æŠ¤åˆ°ç¬¬ 100 æœŸã€‚åŒæ—¶è¿˜è¦è°¢è°¢ Kristaps Grinbergs åœ¨è¿‡å»å‡ ä¸ªæœˆçš„å¹•åå¸®åŠ©ã€‚æ„Ÿè°¢[æ‰€æœ‰å…¶ä»–ä½œè€…](/authors)å’Œåœ¨å¹•åé»˜é»˜å¥‰çŒ®çš„äººã€‚æœ‰äº†ä½ ä»¬ï¼ŒSwift Weekly Brief æ‰èƒ½ç»§ç»­ä¸‹å»ï¼

æœ€åï¼Œéå¸¸æ„Ÿè°¢å¤§å®¶é˜…è¯»å’Œåˆ†äº«æ–°é—»é€šè®¯ï¼å½“æˆ‘ä» Jesse æ¥æ‰‹è¿™ä¸ªé¡¹ç›®æ—¶ï¼Œæˆ‘è¿™æ ·åšä¸»è¦æœ‰ä¸¤ä¸ªåŸå› ï¼šæˆ‘æƒ³
åŠæ—¶äº†è§£ Swift çš„æœ€æ–°åŠ¨æ€ï¼Œå¹¶å‘å…¶ä»–æ„Ÿå…´è¶£çš„äººåˆ†äº«ã€‚å›è¿‡å¤´çœ‹è¿™ä¸ªç›®æ ‡å·²ç»è¾¾æˆäº†ï¼Œè®©æˆ‘ä»¬ä¸€èµ·æœŸå¾…æ˜å¹´ï¼Œç»§ç»­å‰è¿›å§ã€‚

è¯è™½å¦‚æ­¤ï¼Œæˆ‘å¸Œæœ›å¤§å®¶åœ¨æ¥è¿‘ 2019 å¹´çš„å°¾å£°ï¼Œåº¦è¿‡æ„‰å¿«çš„æ¯ä¸€å¤©ã€‚

<!--excerpt-->

### å…¥é—¨ä»»åŠ¡

- [SR-11900](https://bugs.swift.org/browse/SR-11900) [Compiler] `swift help`
doesn't work
- [SR-11905](https://bugs.swift.org/browse/SR-11905) [Compiler] Objective-C
interop allows creation of undefined behavior
- [SR-11918](https://bugs.swift.org/browse/SR-11918) [Compiler] Reject the
combination of `-enable-testing` and `-enable-library-evolution`

### ç¤¾åŒºæ–°é—»

[Tanner Nelson](https://twitter.com/tanner0101) å‘å¸ƒäº† [Vapor 4](https://forums.swift.org/t/whats-new-in-vapor-4/31832)! ğŸ¥³

[Paul Hudson](https://twitter.com/twostraws) å‘å¸ƒäº† [Swift for Good](https://www.swiftforgood.com)ï¼Œä¸€æœ¬ç”± 20 ä¸ªä¸åŒä½œè€…ç¼–å†™çš„æœ‰å…³ Swift è¯é¢˜çš„ä¹¦ï¼Œè¿™æœ¬ä¹¦çš„æ‰€æœ‰æ”¶å…¥éƒ½å°†æèµ æ…ˆå–„æœºæ„ã€‚

[Bruno Rocha](https://twitter.com/rockthebruno) å†™äº†[ä¸€ç¯‡æ–‡ç« ](https://swiftrocks.com/how-optionset-works-inside-the-swift-compiler.html)
å…³äº `OptionSet` åœ¨ Swift ç¼–è¯‘å™¨ä¸­çš„å·¥ä½œåŸç†ã€‚

### åˆå¹¶è¯·æ±‚

[Ankit Aggarwal](https://twitter.com/aciidb0mb3r) åˆå¹¶äº†[ä¸€ä¸ª pull request](https://github.com/apple/swift-package-manager/pull/2468)å…è®¸ä½¿ç”¨é€šè¿‡ `swiftpm` å‘½ä»¤æ„å»ºçš„äºŒè¿›åˆ¶æ–‡ä»¶ã€‚

[Rintaro Ishizaki](https://twitter.com/rintaro) æ–°å»ºäº†[ä¸€ä¸ª pull request](https://github.com/apple/swift/pull/28727)
å…³äºé‡ç”¨ç¼–è¯‘å™¨å¯¹è±¡ä»¥å®ç°æ›´é«˜æ•ˆçš„ä»£ç è¡¥å…¨ã€‚æ›´å¿«æ›´ä¼˜é›…ï¼

[Erik Eckstein](https://github.com/eeckstein) åˆå¹¶äº†[ä¸€ä¸ª pull request](https://github.com/apple/swift/pull/28407)
æ·»åŠ äº†ä¸€ä¸ª cross-module optimization çš„é€‰é¡¹ã€‚

### æ–°æ™‹ææ¡ˆ

[SE-0268](https://github.com/apple/swift-evolution/blob/master/proposals/0268-didset-semantics.md): *Refine `didSet` Semantics* [è¢«æ¥å—](https://forums.swift.org/t/accepted-se-0268-refine-didset-semantics/31822)ã€‚

> The proposal has been accepted [as it was originally proposed](https://github.com/apple/swift-evolution/blob/35537af5e63a140c93521d78fdac3c9e2d9ad349/proposals/0268-didset-semantics.md),
prior to the second review.
>
> The change overall received considerable support, despite being
semantic-breaking in rare cases. Being able to make mutations in-place is an
important performance win and one that many current users might already be
expecting.
>
> The second review proposed a small alteration to the original proposal: to
warn on implicit use of `didSet`, because in the original review some reviewers
felt that accessing the implicit parameter in the body of the function
resulting in the fetching behavior could be harmful, so proposed a deprecation
warning to be silenced by adding the argument explicitly. During the second
review, it became clear that the feeling of most commenters was that the
increased verbosity (and new warnings) did not justify the change. The core
team agrees with the feedback, and so has accepted the original proposal.

### å®¡æ ¸ä¸­ææ¡ˆ

[SE-0270](https://github.com/apple/swift-evolution/blob/master/proposals/0270-rangeset-and-collection-operations.md): *Add Collection Operations on Noncontiguous Elements* [æ­£åœ¨å®¡æ ¸ä¸­](https://forums.swift.org/t/se-0270-review-2-add-collection-operations-on-noncontiguous-elements/31653).

> The proposal was returned for revision in order to investigate splitting it
into smaller pieces. Nate Cook, the proposal author, has chosen to make several
revisions, the most significant of which is to remove several sets of methods;
you can see the raw difference [here](https://github.com/apple/swift-evolution/commit/d61957df1af9fb283da8c0b3108dbea5e3f3b732).
The Core Team has elected to run a review of the proposal as revised rather
than sending it back into the pitch phase.
>
> It sometimes happens with re-reviews that the Core Team has substantively
approved parts of the proposal and is asking the community to provide feedback
on specific revisions. That is not the case here because the Core Team did not
feel like it received a strong signal on the core proposal. Accordingly, please
consider this to be a de novo review and provide feedback on the full proposal.

[SE-0272](https://github.com/apple/swift-evolution/blob/master/proposals/0272-swiftpm-binary-dependencies.md): *Package Manager Binary Dependencies* [æ­£åœ¨å®¡æ ¸ä¸­](https://forums.swift.org/t/se-0272-review-2-package-manager-binary-dependencies/31668)ã€‚

> SwiftPM currently supports source-only packages for several languages, and
with a very proscriptive build model which considerably limits exactly how the
compilation of the source can be performed. While this makes packages consistent
and to some extent "simple", it limits their use in several important cases:
>
> - Software vendors who wish to provide easy integration with the package
manager, but do not deliver source code, cannot integrate.
> - Existing code bases which would like to integrate "simply" with SwiftPM, but
require more complicated build processes, have no recourse.
>
> For example, consider these use cases:
>
> - Someone wants to create a Swift package for
generating [LLVM](https://llvm.org) code. However, LLVM's build process is
far more complex than can be currently fit into SwiftPM's build model. This
makes building an *easy to use* package difficult.
> - A third-party wants to provide a Swift SDK for easily integrating their
service with server-side Swift applications. The SDK itself relies on
substantial amounts of internal infrastructure the company does not want to
make available as open source.
> - A large company has an internal team which wants to deliver a Swift package
for use in their iOS applications, but for for business reasons cannot publish
the source code.
>
> This proposal defines a new SwiftPM feature to allow SwiftPM to accept some
forms of "binary packages". This proposal is intentionally written to
address the above use cases *explicitly*, it **does not** define a general
purpose "binary artifact" mechanism intended to address other use cases (such as
accelerating build performance).

[SE-0273](https://github.com/apple/swift-evolution/blob/master/proposals/0273-swiftpm-conditional-target-dependencies.md): *Package Manager Conditional Target Dependencies* [æ­£åœ¨å®¡æ ¸ä¸­](https://forums.swift.org/t/se-0273-package-manager-conditional-target-dependencies/31667)ã€‚

> This proposal introduces the ability for Swift package authors to
conditionalize target dependencies on platform and configuration with a similar
syntax to the one introduced in
[SE-0238](0238-package-manager-build-settings.md) for build settings. This
gives developers more flexibility to describe complex target dependencies to
support multiple platforms or different configuration environments.
>
> This proposal resolves two use cases that the current version of the Package
Manager doesn't support very well. In the first scenario, packages that span
multiple platforms may need to depend on different libraries depending on the
platform, as can be the case for low-level, platform-specific code. In a second
scenario, packages may want to link against libraries only in certain
configurations, for example when importing debug libraries, which do not make
sense to build and link in release builds, or when importing instrumentation
logic, which only make sense in release builds when the developer can not
benefit from debugging.
>
> This proposal attempts to bring solutions to those use cases by allowing
package authors to define under what build environments dependencies need to be
built and linked against targets.

### è®ºå›åŠ¨å‘

[Joe Groff](https://twitter.com/jckarter) åˆ†äº«äº†[ä¸€äº›å…³äºèŒƒå‹å…ƒæ•°æ®çš„ prespecialization](https://forums.swift.org/t/generic-type-metadata-prespecialization/31659)ã€‚

> One source of memory and performance overhead in Swift code is the
instantiation and fetching of type metadata. Even though generic specialization
eliminates the need for type metadata in most fully-specialized code, we still
need the metadata in many frequently-occurring situations:
>
> - Objects always need their class metadata, which serves as the "isa" pointer
with the object's method table and other dynamic metadata.
> - When putting a value inside an existential box, the type metadata for the
value's type is stored in the box to represent its dynamic type.
> - When calling into unspecialized code, type metadata for the generic type
arguments has to be formed. Code may remain unspecialized because it crosses
ABI boundaries or is invoked via dynamic reflection.

[Tom Doron](https://twitter.com/TomerDoron) åˆ†äº«äº† [Swift æœåŠ¡å™¨ç«¯å·¥ä½œç»„åäºŒæœˆçš„è§é¢ä¼šè®®ç¬”è®°](https://forums.swift.org/t/december-12th-2019/31735)ã€‚

> Ian Partridge and Chris Bailey let the group know that following a review by
IBM of its open source priorities, it has been decided that they will not be
continuing to work on Swift in 2020. As a result, they are both standing down
from the workgroup.
>
> Ian Partridge will work to hand over responsibilities for the Swift Docker
images and suggested a potential new owner from the community.

[Ben Cohen](https://twitter.com/AirspeedSwift) èµ·è‰äº†[ä¸€ä»½è‰æ¡ˆ](https://forums.swift.org/t/pitch-modify-accessors/31872)ä»¥å…¬å¼€ Swift çš„ modify å­˜å–å™¨ã€‚

> We propose the introduction of a new keyword, `modify`, for implementing
mutable computed properties and subscripts, alongside the current `get` and
`set`.
>
> The bodies of `modify` implementations will be coroutines, and they will
introduce a new contextual keyword, `yield`, that will be used to yield a value
to be modified back to the caller. Control will resume after the `yield` when
the caller returns.
>
> This `modify` feature is currently available (but not supported) from Swift
5.0 as `_modify`, for experimentation purposes when reviewing this proposal.

[Matthew Johnson](https://twitter.com/anandabits) èµ·è‰äº†[ä¸€ä»½è‰æ¡ˆ](https://forums.swift.org/t/anonymous-structs/31424)ä»¥å¼•å…¥åŒ¿åçš„ struct ç±»å‹ã€‚

> This proposal introduces anonymous structs using closure-inspired syntactic
sugar as an alternative to a more verbose local struct declaration. As with
closures, trailing syntax is supported.
>
> While Swift has often been called a protocol-oriented language it still lacks
some features necessary to facilitate protocol-oriented library designs in
practice. One missing feature is syntactic support for ad-hoc, single-use
conformances on par with the expressivity that closures provide for ad-hoc,
single-use functions.
>
> Local type declarations involve a lot of syntactic ceremony that is
unnecessary for singe-use types. This ceremony includes a name, explicit
protocol conformance declarations, and fully written declarations for all
members. In addition to the ceremony of the local type declaration itself, use
of the type requires explicit instantiation, which may itself be verbose if
there are several stored properties to initialize.

### å°¾å£°

A ["funny" Swift thing](https://twitter.com/slava_pestov/status/1206398538743193600).
